From 1d4f1176553f1691ed7a90770891ea799bf404dd Mon Sep 17 00:00:00 2001
From: Song Bing <b06498@freescale.com>
Date: Thu, 14 Apr 2016 15:14:13 +0800
Subject: [PATCH] [RendererIMX] Add GPU 3D render support.

Can use GPU 3D render or 2D render based on one micro.

Signed-off-by: Song Bing bing.song@nxp.com
---
 .../VideoRenderers/HwDecRender/RendererIMX.cpp     | 214 ++++++++++++++++++++-
 .../VideoRenderers/HwDecRender/RendererIMX.h       |   7 +-
 2 files changed, 219 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.cpp
index ed5b643..ab63544 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.cpp
@@ -33,16 +33,37 @@
 
 #define RENDER_FLAG_FIELDS (RENDER_FLAG_FIELD0 | RENDER_FLAG_FIELD1)
 
+#ifdef USE_3D
+#define GL_VIV_NV12 0x8FC1
+typedef void (GL_APIENTRYP PFNGLTEXDIRECTVIVMAPPROC) (GLenum Target, GLsizei Width, GLsizei Height, GLenum Format, GLvoid ** Logical, const GLuint * Physical);
+typedef void (GL_APIENTRYP PFNGLTEXDIRECTINVALIDATEVIVPROC) (GLenum Target);
+static PFNGLTEXDIRECTVIVMAPPROC glTexDirectVIVMap;
+static PFNGLTEXDIRECTINVALIDATEVIVPROC glTexDirectInvalidateVIV;
+#endif
+
 CRendererIMX::CRendererIMX()
 {
-
+#ifdef USE_3D
+  if (!glTexDirectVIVMap)
+    glTexDirectVIVMap = (PFNGLTEXDIRECTVIVMAPPROC) CEGLWrapper::GetProcAddress("glTexDirectVIVMap");
+  if (!glTexDirectInvalidateVIV)
+    glTexDirectInvalidateVIV = (PFNGLTEXDIRECTINVALIDATEVIVPROC) CEGLWrapper::GetProcAddress("glTexDirectInvalidateVIV");
+#endif
 }
 
 CRendererIMX::~CRendererIMX()
 {
+#ifdef USE_3D
+  for (int i = 0; i < NUM_BUFFERS; ++i)
+  {
+    DeleteTexture(i);
+  }
+#else
   UnInit();
+#endif
 }
 
+#ifndef USE_3D
 bool CRendererIMX::RenderCapture(CRenderCapture* capture)
 {
   CRect rect(0, 0, capture->GetWidth(), capture->GetHeight());
@@ -53,11 +74,16 @@ bool CRendererIMX::RenderCapture(CRenderCapture* capture)
   capture->EndRender();
   return true;
 }
+#endif
 
 void CRendererIMX::AddVideoPictureHW(DVDVideoPicture &picture, int index)
 {
   YUVBUFFER &buf = m_buffers[index];
 
+#ifdef USE_3D
+  if (buf.hwDec)
+    ReleaseBuffer(index);
+#endif
   buf.hwDec = picture.IMXBuffer;
 
   if (picture.IMXBuffer)
@@ -78,11 +104,18 @@ int CRendererIMX::GetImageHook(YV12Image *image, int source, bool readonly)
 
 bool CRendererIMX::IsGuiLayer()
 {
+#ifdef USE_3D
+  return true;
+#else
   return false;
+#endif
 }
 
 bool CRendererIMX::Supports(EINTERLACEMETHOD method)
 {
+#ifdef USE_3D
+    return false;
+#else
   if(method == VS_INTERLACEMETHOD_AUTO)
     return true;
 
@@ -91,26 +124,41 @@ bool CRendererIMX::Supports(EINTERLACEMETHOD method)
     return true;
   else
     return false;
+#endif
 }
 
 bool CRendererIMX::Supports(EDEINTERLACEMODE mode)
 {
+#ifdef USE_3D
+  return false;
+#else
   if(mode == VS_DEINTERLACEMODE_AUTO
   || mode == VS_DEINTERLACEMODE_FORCE
   || mode == VS_DEINTERLACEMODE_OFF)
     return true;
 
   return false;
+#endif
 }
 
 bool CRendererIMX::Supports(ESCALINGMETHOD method)
 {
+#ifdef USE_3D
+    if(method == VS_SCALINGMETHOD_NEAREST
+          || method == VS_SCALINGMETHOD_LINEAR)
+          return true;
+#else
   return false;
+#endif
 }
 
 EINTERLACEMETHOD CRendererIMX::AutoInterlaceMethod()
 {
+#ifdef USE_3D
+  return VS_INTERLACEMETHOD_NONE;
+#else
   return VS_INTERLACEMETHOD_IMX_FASTMOTION;
+#endif
 }
 
 CRenderInfo CRendererIMX::GetRenderInfo()
@@ -133,9 +181,89 @@ bool CRendererIMX::LoadShadersHook()
 
 bool CRendererIMX::RenderHook(int index)
 {
+#ifdef USE_3D
+#ifdef DEBUG_VERBOSE
+  unsigned int time = XbmcThreads::SystemClockMillis();
+#endif
+
+  YUVPLANE &plane = m_buffers[index].fields[0][0];
+  CDVDVideoCodecIMXBuffer *buffer =  static_cast<CDVDVideoCodecIMXBuffer*>(m_buffers[index].hwDec);
+
+  CLog::Log(LOGDEBUG, "GL: Using IMXMAP render method: %s  %d", __FUNCTION__, __LINE__);
+  if(buffer == NULL) return false;
+
+  CDVDVideoCodecIMX::Enter();
+
+  if(!buffer->IsValid())
+  {
+    CDVDVideoCodecIMX::Leave();
+    return false;
+  }
+
+  CLog::Log(LOGDEBUG, "GL: Using IMXMAP render method: %s  %d", __FUNCTION__, __LINE__);
+  glDisable(GL_DEPTH_TEST);
+
+  glActiveTexture(GL_TEXTURE0);
+  glBindTexture(m_textureTarget, plane.id);
+
+  g_Windowing.EnableGUIShader(SM_TEXTURE_RGBA);
+
+  GLubyte idx[4] = {0, 1, 3, 2};        //determines order of triangle strip
+  GLfloat ver[4][4];
+  GLfloat tex[4][2];
+  GLfloat col[3] = {1.0f, 1.0f, 1.0f};
+
+  GLint   posLoc = g_Windowing.GUIShaderGetPos();
+  GLint   texLoc = g_Windowing.GUIShaderGetCoord0();
+  GLint   colLoc = g_Windowing.GUIShaderGetCol();
+
+  glVertexAttribPointer(posLoc, 4, GL_FLOAT, 0, 0, ver);
+  glVertexAttribPointer(texLoc, 2, GL_FLOAT, 0, 0, tex);
+  glVertexAttribPointer(colLoc, 3, GL_FLOAT, 0, 0, col);
+
+  glEnableVertexAttribArray(posLoc);
+  glEnableVertexAttribArray(texLoc);
+  glEnableVertexAttribArray(colLoc);
+
+  // Set vertex coordinates
+  for(int i = 0; i < 4; i++)
+  {
+    ver[i][0] = m_rotatedDestCoords[i].x;
+    ver[i][1] = m_rotatedDestCoords[i].y;
+    ver[i][2] = 0.0f;// set z to 0
+    ver[i][3] = 1.0f;
+  }
+
+  // Set texture coordinates
+  tex[0][0] = tex[3][0] = plane.rect.x1;
+  tex[0][1] = tex[1][1] = plane.rect.y1;
+  tex[1][0] = tex[2][0] = plane.rect.x2;
+  tex[2][1] = tex[3][1] = plane.rect.y2;
+
+  CLog::Log(LOGDEBUG, "GL: Using IMXMAP render method: %s  %d", __FUNCTION__, __LINE__);
+  glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, idx);
+
+  glDisableVertexAttribArray(posLoc);
+  glDisableVertexAttribArray(texLoc);
+  glDisableVertexAttribArray(colLoc);
+
+  g_Windowing.DisableGUIShader();
+  VerifyGLState();
+
+  glBindTexture(m_textureTarget, 0);
+  VerifyGLState();
+
+  CDVDVideoCodecIMX::Leave();
+
+#ifdef DEBUG_VERBOSE
+  CLog::Log(LOGDEBUG, "RenderIMXMAPTexture %d: tm:%d\n", index, XbmcThreads::SystemClockMillis() - time);
+#endif
+#else
   return true;// nothing to be done for imx
+#endif
 }
 
+#ifndef USE_3D
 bool CRendererIMX::RenderUpdateVideoHook(bool clear, DWORD flags, DWORD alpha)
 {
 #if 0
@@ -206,20 +334,104 @@ bool CRendererIMX::RenderUpdateVideoHook(bool clear, DWORD flags, DWORD alpha)
 
   return true;
 }
+#endif
 
 bool CRendererIMX::CreateTexture(int index)
 {
+#ifdef USE_3D
+  YV12Image &im     = m_buffers[index].image;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE  &plane  = fields[0][0];
+
+  DeleteTexture(index);
+
+  memset(&im    , 0, sizeof(im));
+  memset(&fields, 0, sizeof(fields));
+
+  im.height = m_sourceHeight;
+  im.width  = m_sourceWidth;
+
+  plane.texwidth  = 0; // Must be actual frame width for pseudo-cropping
+  plane.texheight = 0; // Must be actual frame height for pseudo-cropping
+  plane.pixpertex_x = 1;
+  plane.pixpertex_y = 1;
+
+  glEnable(m_textureTarget);
+  glGenTextures(1, &plane.id);
+  VerifyGLState();
+
+  glBindTexture(m_textureTarget, plane.id);
+
+  glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+  glDisable(m_textureTarget);
   return true;
+#else
+  return true;
+#endif
 }
 
 void CRendererIMX::DeleteTexture(int index)
 {
+#ifdef USE_3D
+  YUVBUFFER &buf = m_buffers[index];
+  YUVPLANE &plane = buf.fields[0][0];
+
+  if(plane.id && glIsTexture(plane.id))
+    glDeleteTextures(1, &plane.id);
+  plane.id = 0;
+
+  ReleaseBuffer(index);
+#else
   ReleaseBuffer(index);
+#endif
 }
 
 bool CRendererIMX::UploadTexture(int index)
 {
+#ifdef USE_3D
+  YUVBUFFER& buf =  m_buffers[index];
+  CDVDVideoCodecIMXBuffer *IMXBuffer =  static_cast<CDVDVideoCodecIMXBuffer*>(m_buffers[index].hwDec);
+
+  CLog::Log(LOGDEBUG, "GL: Using IMXMAP render method: %s  %d", __FUNCTION__, __LINE__);
+  if(IMXBuffer)
+  {
+    CDVDVideoCodecIMX::Enter();
+
+    if(!IMXBuffer->IsValid())
+    {
+      CDVDVideoCodecIMX::Leave();
+      return false;
+    }
+
+  CLog::Log(LOGDEBUG, "GL: Using IMXMAP render method: %s  %d", __FUNCTION__, __LINE__);
+    YUVPLANE &plane = m_buffers[index].fields[0][0];
+
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(m_textureTarget, plane.id);
+
+    GLuint physical = (GLuint)IMXBuffer->pPhysAddr;
+    GLvoid *virt = (GLvoid*)IMXBuffer->pVirtAddr;
+    glTexDirectVIVMap(m_textureTarget, IMXBuffer->iWidth, IMXBuffer->iHeight, GL_VIV_NV12,
+        (GLvoid **)&virt, &physical);
+    glTexDirectInvalidateVIV(m_textureTarget);
+
+    glBindTexture(m_textureTarget, 0);
+
+    plane.flipindex = m_buffers[index].flipindex;
+    plane.texwidth  = IMXBuffer->iWidth;
+    plane.texheight = IMXBuffer->iHeight;
+
+    CalculateTextureSourceRects(index, 1);
+
+    CDVDVideoCodecIMX::Leave();
+  }
+
+  return true;
+#else
   return true;// nothing todo for IMX
+#endif
 }
 #endif
 
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.h b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.h
index 22b1ed0..e6e2910 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.h
@@ -26,13 +26,16 @@
 
 #include "cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.h"
 
+#define USE_3D
+
 class CRendererIMX : public CLinuxRendererGLES
 {
 public:
   CRendererIMX();
   virtual ~CRendererIMX();
-  
+#ifndef USE_3D
   virtual bool RenderCapture(CRenderCapture* capture);
+#endif
 
   // Player functions
   virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index);
@@ -59,7 +62,9 @@ protected:
   virtual bool LoadShadersHook();
   virtual bool RenderHook(int index);  
   virtual int  GetImageHook(YV12Image *image, int source = AUTOSOURCE, bool readonly = false);
+#ifndef USE_3D
   virtual bool RenderUpdateVideoHook(bool clear, DWORD flags = 0, DWORD alpha = 255);
+#endif
 };
 
 #endif
-- 
1.9.1

